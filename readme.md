# Домашние задания по курсу "Основы системного программирования"

## Взлом пароля

С помощью `readelf` обнаружил, что надо менять `st_other` в `_Z12authenticatePKc` с `PROTECTED` на `DEFAULT`:

```console
(base) robert@qot-calc0:~/sysprog_2025$ readelf -s libsecret.so | grep authenticate
 6: 0000000000001119    19 FUNC    GLOBAL PROTECTED   12 _Z12authenticatePKc
 24: 0000000000001119    19 FUNC    GLOBAL PROTECTED   12 _Z12authenticatePKc
```

Для этого написал программу `vzlom.cpp`, которая патчит нужный символ на необходимую видимость. В нашем случае это `_Z12authenticatePKc` и `STV_DEFAULT`.

Потом делаем следующее

```console
(base) robert@qot-calc0:~/sysprog_2025$ ls
 elf.h   libsecret.so   main.cpp   vzlom_pop.cpp  'Задание 5 ELF.pdf'
(base) robert@qot-calc0:~/sysprog_2025$ g++ vzlom_pop.cpp -o vzlom_pop
(base) robert@qot-calc0:~/sysprog_2025$ ./vzlom_pop libsecret.so
symbol visibility changed successfully.
(base) robert@qot-calc0:~/sysprog_2025$ g++ main.cpp -o password -L. -lsecret
(base) robert@qot-calc0:~/sysprog_2025$ LD_LIBRARY_PATH=. ./password
Enter password: kushay kashu
Access GRANTED. Top secret = 462074591
```

Получили пароль `Top secret = 462074591`. Для проверки все файлы лежат в `vzlom_password`.

```console
(base) robert@qot-calc0:~/sysprog_2025/vzlom_password$ readelf -s libsecret.so | grep authenticate
     6: 0000000000001119    19 FUNC    GLOBAL DEFAULT   12 _Z12authenticatePKc
    24: 0000000000001119    19 FUNC    GLOBAL PROTECTED   12 _Z12authenticatePKc
```


## Задачи по C++ 

Решения этих задач представлен в папке `some c++ problems`.

1. Виртуальный деструктор

> Даны классы `A, B, C`. Причём C публично наследуется от `A` и `B`. Деструктор у класса `A` виртуальный, а у `B` – не виртуальный. Какой деструктор будет у `C`? Напишите программу, которая наглядно это демонстрирует.

У `С` будет виртуальный деструктор, так как он наследует класс `A`, у которого деструктор виртуальный. Причем этот результат не зависит от того, что деструктор класса `B` не виртуальный. Для проверки этого написана программа `virt_d.cpp` в папке `some c++ problems`. Вызов 
строчки 

```c++
A* a_ptr = new C();
delete a_ptr;
```
Ставит ссылку на подкласс `A`, который лежит внутри класса `C`. Если деструктор `A` был бы не виртуальный, то вызвался бы только он. Однако, в нашем случае будут вызываться все деструкторы из-за полиморфизма: сначала вызовется деструктор `C`, а затем деструктор `A` и `B`
```c++
Создание и удаление через указатель A (виртуальный)
~C()
~B()
~A()
```
При следующем
```c++
B* b_ptr = new C();
delete b_ptr;
```
Имеем вывод 
```c++
Создание и удаление через указатель B (не виртуальный)
~B()
```
То есть вызвался дестуктор только класса `B` - полиморфизма не произошло, так как класс `B` - не виртуальный.

2. Приведение типов

>Даны классы `A, B, C`, каждый из которых содержит поле данных типа `int`. Класс C наследуется от `A` и `B`. Создайте экземпляр класса: `C c`. Выведите адрес `&c`, выполните преобразования `static_cast<A*>(&c)`, `static_cast<B*>(&c)`, `reinterpret_cast<A*>(&c)`, `reinterpret_cast<B*>(&c)`. Какие адреса возвращаются после преобразования? Объясните полученные результаты. Какому преобразованию (`static_cast` или `reinterpret_cast`) эквивалентно преобразование типов в стиле Си?

Написанная программа `prived_types.cpp` лежит в папке `some c++ problems`. Вывод программы следующий
```c++
Address of c:          0x16fc2a4f0
static_cast<A*>(&c):   0x16fc2a4f0
static_cast<B*>(&c):   0x16fc2a4f4
reinterpret_cast<A*>(&c): 0x16fc2a4f0
reinterpret_cast<B*>(&c): 0x16fc2a4f0

Offsets (in bytes):
A offset: 0
B offset: 4
```

Сначала создается ссылка на класс `C c`. Затем `static_cast<A*>(&c)` вернет адрес `A` внутри этого класса. Он совпадет с адресом `c`, так как расположен вначале класса. Затем `static_cast<B*>(&c)` вернет адрес `B` внутри класса `c` и он будет сдвинут на 4 байта - размер `int`. Когда мы применяем `reinterpret_cast<A*>(&c)`, то мы просто копируем адрес `&c` на `A*`: будет срабатывать корректно, так как у них итак адресы совпадают. Но когда мы применяем `reinterpret_cast<B*>(&c)`, то копируем адрес `&c` на `B*`, но они отличаются на 4 байта, то есть указатель на `B*` будет показывать не реальное положение класса `B` внутри `с`. 

Преобразованию типов в стиле Си эквивалентно преобразованиям `static_cast`, который предназначен для безопасного преобразования типов в рамках одной иерархии наследования. Это означает, что с наследованием все будет хорошо, то есть адреса будут грамотно отображаться.

## Двусвязный список

Эту задачу решил в папке `Двусвязный список`. Все необходимые методы реализованы, пояснения тоже есть.

## Фоковские состояния

Вся реализация программы продемонстрирована в папке `focks` в программах `state.h` и `main.cpp`.  Тут я отвечу на дополнительные вопросы.


>1. Можно ли реализовать операцию сложения двух состояний за линейное время, представив состояние в виде несортированного вектора (см. ниже)? 
```c++
struct Element
{
Fock f;
Amp a;
}
using State = std::vector<Element>;
```

Нет, нельзя, так как упорядочивание `Fock` в лексикографическом порядке является ключевым.  В элемент `Element` фоковские состояния могут лежать совершенно в разнобой, что приводит к поиску по всему вектору требуемого состояния `Fock` у `Element`, которое прибавляем к изначальному `Element`. Таким образом операция сложения займет $O(L_1 \cdot L_2)$.

> 2. Можно ли реализовать операцию сложения двух состояний за линейное время, заменив `std::map` на хэш-таблицу `std::unordered_map`, в которой операции вставки, удаления и доступа по ключу выполняются за константное время 

Да, тут все хорошо получится. Сначала мы потратим $O(L_1)$ для инициализации `State result = s1`. Потом итерируемся по `s2`, ну а так как доступ по ключу реализуется за `O(1)`, а итерироваться мы будем `L_2` раз, тогда итоговая сложность $O(L_1) + O(L_2) = O(L_1 + L_2)$


## Template expression (Sum + Transpose)
Вся реализация программы продемонстрирована в папке `expression_templates`. Прописал все `TODO` в каждом файле. Пример вывода в `main.cpp`.

```c++
0 0 0 0 0 
0 0 0 0 0 
0 12 0 0 0 
0 0 0 0 0 
0 0 0 34 0 
Index out of bounds
```
Сначала выводится матрица. Затем проверяется реализован ли учет ошибок.

## Перманент

> Напишите функцию вычисления перманента квадратной матрицы `A` на языках `Python` и `C++`. В обеих реализациях используйте один и тот же алгоритм расчёта. Для вычисления перманента можно использовать [формулу Глина](https://en.wikipedia.org/wiki/Computing_the_permanent). Для хранения матриц используйте типы из библиотек `Eigen (C++)` и `Numpy (Python)`. `C++` код оберните в модуль `Python`. Прототип функции должен быть следующий:

```cpp
double permanent(const Eigen::MatrixXcd &A) // C++
```
```python
def permanent(A: numpy.matrix) -> float # python
```

> Сравните время выполнения функции из модуля-обёртки и реализации на чистом `Python` для матриц различного размера, постройте соответвующий график.

Решение всего задания представлено в папке `permanent`, где обертка функции из `c++` в `python` была выполнена с помощью `pybind11`. Сравнение результатов проведено в `some_check.ipynb`: сравнивалось с функцией в `python`, которая использовалась с `numba`.